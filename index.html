<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Particle System</title>
    <style>
        :root {
            --primary-color: #00f3ff;
            --bg-glass: rgba(15, 15, 25, 0.85);
            --accent: #ff0055;
        }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        #input-video { display: none; }

        /* UI Sidebar */
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            padding: 24px;
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
            color: white;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        h3 { margin: 0 0 15px 0; font-weight: 600; letter-spacing: 1px; font-size: 1.1rem; color: #fff; }
        
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-size: 0.85rem; color: #aaa; font-weight: 500; }
        
        /* Custom Select & Inputs */
        select, input[type="color"], button {
            width: 100%;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3);
            color: white;
            outline: none;
            transition: all 0.2s;
        }

        select {
            padding: 10px;
            cursor: pointer;
            appearance: none; /* Remove default arrow */
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%2300f3ff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 12px top 50%;
            background-size: 10px auto;
        }
        select:hover, input[type="color"]:hover { border-color: var(--primary-color); }

        /* Color Picker */
        input[type="color"] { height: 44px; padding: 2px; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 6px; }

        /* Status Box */
        #status-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            color: var(--primary-color);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            border-left: 3px solid var(--primary-color);
        }

        /* Instructions */
        .instructions {
            font-size: 0.8rem;
            color: #888;
            margin-top: 20px;
            line-height: 1.6;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
        }
        .instructions b { color: #fff; }

        /* Loader */
        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            font-family: monospace;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <video id="input-video"></video>
    <div id="loader">INITIALIZING NEURAL NETWORKS...<br><span style="color:#666">Please allow camera access</span></div>

    <aside id="ui-panel">
        <h3>COSMIC CONTROL</h3>
        
        <div class="control-group">
            <label>Cosmic Structure (Preset)</label>
            <select id="preset-selector">
                <option value="UNIVERSE">Universe (Chaos)</option>
                <option value="PLANET">Planet (Sphere)</option>
                <option value="MILKYWAY" selected>Milky Way (Galaxy)</option>
                <option value="BLACKHOLE">Black Hole (Accretion)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Matter Color</label>
            <input type="color" id="color-picker" value="#00f3ff">
        </div>

        <div class="control-group">
            <label>System Status</label>
            <div id="status-box">Scanning...</div>
        </div>
        
        <div class="instructions">
            <div>‚úä <b>Fist:</b> Gravity Collapse (Speed Up)</div>
            <div>‚úã <b>Open:</b> Expansion (Slow Down)</div>
            <div>‚òùÔ∏è <b>Point:</b> Direct Flow (Rotate)</div>
            <div>‚úåÔ∏è <b>Victory:</b> Quantum Turbulence</div>
            <div>üôè <b>Two Hands:</b> Summon Portal</div>
        </div>
    </aside>

    <script>
        /**
         * Module 1: UI Manager
         */
        class UIManager {
            constructor(callbacks) {
                this.statusBox = document.getElementById('status-box');
                this.loader = document.getElementById('loader');
                
                // Event Listeners
                document.getElementById('color-picker').addEventListener('input', (e) => callbacks.onColor(e.target.value));
                document.getElementById('preset-selector').addEventListener('change', (e) => callbacks.onPreset(e.target.value));
            }

            updateStatus(text, active) {
                this.statusBox.innerHTML = text;
                this.statusBox.style.color = active ? '#ff0055' : '#00f3ff';
                this.statusBox.style.borderColor = active ? '#ff0055' : '#00f3ff';
            }

            hideLoader() { this.loader.style.display = 'none'; }
        }

        /**
         * Module 2: Particle Physics Engine
         */
        class ParticleEngine {
            constructor() {
                this.container = document.body;
                this.params = {
                    count: 5000,
                    size: 0.15,
                    color: 0x00f3ff,
                    type: 'MILKYWAY'
                };
                
                // Physics State
                this.rotationSpeed = { x: 0, y: 0.002 };
                this.targetRotation = { x: 0, y: 0.002 };
                this.turbulence = 0;
                this.targetTurbulence = 0;
                this.expansion = 1;
                this.targetExpansion = 1;

                this.initThree();
                this.setPreset('MILKYWAY');
                this.animate();
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.002); // Deep space fog

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 30;
                this.camera.position.y = 10;
                this.camera.lookAt(0,0,0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.container.appendChild(this.renderer.domElement);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            // --- Geometry Generators ---
            setPreset(type) {
                this.params.type = type;
                if (this.particleSystem) this.scene.remove(this.particleSystem);
                if (this.magicRing) this.scene.remove(this.magicRing);

                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.params.count * 3);
                
                // Store initial positions for turbulence reset
                this.initialPositions = new Float32Array(this.params.count * 3);

                for (let i = 0; i < this.params.count; i++) {
                    let x, y, z;
                    const i3 = i * 3;

                    if (type === 'UNIVERSE') {
                        // Random Cube
                        x = (Math.random() - 0.5) * 100;
                        y = (Math.random() - 0.5) * 100;
                        z = (Math.random() - 0.5) * 100;
                    } 
                    else if (type === 'PLANET') {
                        // Sphere Surface
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        const r = 15;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    }
                    else if (type === 'MILKYWAY') {
                        // Spiral Galaxy
                        const branchAngle = (i % 3) * ((2 * Math.PI) / 3);
                        const r = Math.random() * 20 + 2;
                        const spin = r * 0.5; // Twist based on radius
                        const randomOffset = Math.random() - 0.5; // Thickness
                        
                        x = Math.cos(branchAngle + spin) * r + (Math.random()-0.5);
                        z = Math.sin(branchAngle + spin) * r + (Math.random()-0.5);
                        y = (Math.random() - 0.5) * (20/r); // Thicker center, thinner edges
                    }
                    else if (type === 'BLACKHOLE') {
                        // Accretion Disk
                        const r = Math.random() * 15 + 8; // Hole in middle (0-8)
                        const theta = Math.random() * Math.PI * 2;
                        x = r * Math.cos(theta);
                        z = r * Math.sin(theta);
                        y = (Math.random() - 0.5) * 0.5; // Very flat
                    }

                    positions[i3] = x;
                    positions[i3+1] = y;
                    positions[i3+2] = z;
                    this.initialPositions[i3] = x;
                    this.initialPositions[i3+1] = y;
                    this.initialPositions[i3+2] = z;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: this.params.color,
                    size: this.params.size,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                this.particleSystem = new THREE.Points(geometry, material);
                this.scene.add(this.particleSystem);

                // Re-add portal ring (hidden)
                this.createPortal();
            }

            createPortal() {
                const geo = new THREE.TorusGeometry(12, 0.5, 16, 100);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 });
                this.magicRing = new THREE.Mesh(geo, mat);
                this.magicRing.visible = false;
                this.scene.add(this.magicRing);
            }

            // --- Interaction Logic ---
            updateProps(color) {
                this.params.color = new THREE.Color(color);
                if (this.particleSystem) this.particleSystem.material.color = this.params.color;
            }

            handleGesture(data) {
                const lerp = 0.05;

                // 1. Two Hands = Portal (Override everything)
                if (data.isMagic) {
                    this.magicRing.visible = true;
                    this.magicRing.rotation.z += 0.05;
                    this.targetExpansion = 0.5; // Compress into portal
                    this.targetRotation.y = 0.05; // Fast spin
                    this.targetTurbulence = 0;
                    return; 
                } 
                this.magicRing.visible = false;

                // 2. Gesture Mapping
                switch (data.gesture) {
                    case 'FIST': // Gravity (Shrink + Speed)
                        this.targetExpansion = 0.4;
                        this.targetRotation.y = 0.05;
                        this.targetTurbulence = 0.1;
                        break;
                    
                    case 'OPEN': // Expand (Slow)
                        this.targetExpansion = 2.0;
                        this.targetRotation.y = 0.001;
                        this.targetTurbulence = 0;
                        break;
                    
                    case 'POINT': // Directional Control
                        this.targetExpansion = 1.0;
                        // Map hand X pos (0-1) to Rotation X/Y
                        const handX = data.handPos.x - 0.5;
                        this.targetRotation.y = handX * 0.2; // Spin based on hand L/R
                        this.targetRotation.x = (data.handPos.y - 0.5) * 0.2;
                        break;

                    case 'VICTORY': // Turbulence / Glitch
                        this.targetExpansion = 1.2;
                        this.targetTurbulence = 1.5; // High noise
                        this.targetRotation.y = 0; // Freeze rotation
                        break;

                    default: // Idle
                        this.targetExpansion = 1.0;
                        this.targetRotation.y = 0.002;
                        this.targetRotation.x = 0;
                        this.targetTurbulence = 0;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const positions = this.particleSystem.geometry.attributes.position.array;
                const count = this.params.count;
                
                // Smooth variable transitions
                this.expansion += (this.targetExpansion - this.expansion) * 0.05;
                this.turbulence += (this.targetTurbulence - this.turbulence) * 0.05;
                this.rotationSpeed.y += (this.targetRotation.y - this.rotationSpeed.y) * 0.05;
                this.rotationSpeed.x += (this.targetRotation.x - this.rotationSpeed.x) * 0.05;

                // Apply Global Rotation
                this.particleSystem.rotation.y += this.rotationSpeed.y;
                this.particleSystem.rotation.x += this.rotationSpeed.x;

                // Apply Vertex Manipulation (Turbulence & Expansion)
                // We use initialPositions to avoid permanent deformation
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    const ox = this.initialPositions[i3];
                    const oy = this.initialPositions[i3+1];
                    const oz = this.initialPositions[i3+2];

                    // Noise calculation
                    const noiseX = (Math.random() - 0.5) * this.turbulence;
                    const noiseY = (Math.random() - 0.5) * this.turbulence;
                    const noiseZ = (Math.random() - 0.5) * this.turbulence;

                    positions[i3] = ox * this.expansion + noiseX;
                    positions[i3+1] = oy * this.expansion + noiseY;
                    positions[i3+2] = oz * this.expansion + noiseZ;
                }

                this.particleSystem.geometry.attributes.position.needsUpdate = true;
                this.renderer.render(this.scene, this.camera);
            }
        }

        /**
         * Module 3: Hand Logic (Enhanced)
         */
        class HandBrain {
            constructor(onUpdate) {
                this.onUpdate = onUpdate;
                this.hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                this.hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6 });
                this.hands.onResults((res) => this.process(res));

                const video = document.getElementById('input-video');
                const cam = new Camera(video, {
                    onFrame: async () => await this.hands.send({image: video}),
                    width: 640, height: 480
                });
                cam.start();
            }

            process(results) {
                let state = { gesture: 'NONE', isMagic: false, text: 'No Hand', handPos: {x:0.5, y:0.5} };

                if (results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    state.handPos = { x: lm[9].x, y: lm[9].y }; // Middle knuckle as center

                    // Check for Dual Hands (Magic Portal)
                    if (results.multiHandLandmarks.length === 2) {
                        const lm2 = results.multiHandLandmarks[1];
                        const dist = Math.hypot(lm[0].x - lm2[0].x, lm[0].y - lm2[0].y);
                        if (dist < 0.2) {
                            state.isMagic = true;
                            state.text = "‚ú® DIMENSIONAL PORTAL ‚ú®";
                            this.onUpdate(state);
                            return;
                        }
                    }

                    // Classify Single Hand Gesture
                    state.gesture = this.classifyGesture(lm);
                    
                    // Update Text
                    const map = {
                        'FIST': '‚úä GRAVITY COLLAPSE',
                        'OPEN': '‚úã EXPANSION',
                        'POINT': '‚òùÔ∏è DIRECTING FLOW',
                        'VICTORY': '‚úåÔ∏è TURBULENCE',
                        'NONE': 'Searching...'
                    };
                    state.text = map[state.gesture] || map.NONE;
                }

                this.onUpdate(state);
            }

            classifyGesture(lm) {
                // Fingers: Thumb(4), Index(8), Middle(12), Ring(16), Pinky(20)
                // Helper: Is finger extended? (Tip y < PIP y) *Note: Y is inverted in screen space
                // But simplified: distance from wrist(0)
                const wrist = lm[0];
                const isExtended = (tipId) => {
                    const distTip = Math.hypot(lm[tipId].x - wrist.x, lm[tipId].y - wrist.y);
                    const distPip = Math.hypot(lm[tipId-2].x - wrist.x, lm[tipId-2].y - wrist.y);
                    return distTip > distPip + 0.05; // Significant difference
                };

                const thumb = isExtended(4);
                const index = isExtended(8);
                const middle = isExtended(12);
                const ring = isExtended(16);
                const pinky = isExtended(20);

                let extendedCount = [index, middle, ring, pinky].filter(Boolean).length;

                // Logic Tree
                if (extendedCount === 0) return 'FIST';
                if (extendedCount === 4) return 'OPEN';
                if (index && middle && !ring && !pinky) return 'VICTORY'; // V Sign
                if (index && !middle && !ring && !pinky) return 'POINT'; // One finger
                
                return 'OPEN'; // Default fallback
            }
        }

        // --- Bootstrap ---
        window.onload = () => {
            const engine = new ParticleEngine();
            const ui = new UIManager({
                onColor: (c) => engine.updateProps(c),
                onPreset: (t) => engine.setPreset(t)
            });

            new HandBrain((data) => {
                if (data.text !== 'No Hand') ui.hideLoader();
                ui.updateStatus(data.text, data.isMagic || data.gesture === 'VICTORY');
                engine.handleGesture(data);
            });
        };
    </script>
</body>
</html>
